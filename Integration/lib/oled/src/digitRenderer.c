/*
* This light-weight library provides functionality to render numeric digits and sysmbols 
* on the SSD1306 128x64 OLED Display module.
* It makes use of the "mapGen" utility (part of this repository) to create 16x16 bitmaps 
* for digits and symbols.
* Using the magGen utility, it can be extended to include alphabets and other ASCII/UTF 
* characters and render text on the display.
* To communicate with the SSD1306 device, it uses "i2csend" utility (part of this repsitory)
* to send commands and data (bitmaps).
*/

#include<stdio.h>
#include "../include/digitRenderer.h"
#include "../include/i2cSend.h"

#define NUM_DIGITS 10
#define NUM_IP 12
#define NUM_SYMBOLS 5

/*Generated using mapGen utility*/
unsigned char digitMap[NUM_DIGITS][32]={
    {0x0, 0x0, 0x0, 0x0, 0xf8, 0xfc, 0x1e, 0xe, 0xe, 0x1e, 0xfc, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x3f, 0x78, 0x70, 0x70, 0x78, 0x3f, 0x1f, 0x0, 0x0, 0x0, 0x0}, //0
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x18, 0xfc, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x70, 0x70, 0x7f, 0x7f, 0x70, 0x70, 0x0, 0x0, 0x0, 0x0, 0x0},     //1
    {0x0, 0x0, 0x0, 0x0, 0x1c, 0x1e, 0xe, 0xe, 0x8e, 0xce, 0xfe, 0x7c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78, 0x7c, 0x7e, 0x77, 0x73, 0x71, 0x70, 0x70, 0x0, 0x0, 0x0, 0x0}, //2
    {0x0, 0x0, 0x0, 0x0, 0x1c, 0x1e, 0xe, 0x8e, 0x8e, 0xce, 0xfe, 0x7c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x78, 0x70, 0x71, 0x71, 0x73, 0x7f, 0x3e, 0x0, 0x0, 0x0, 0x0},//3
    {0x0, 0x0, 0x0, 0x0, 0x80, 0xc0, 0xe0, 0x70, 0x38, 0xfc, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf, 0xe, 0xe, 0x4e, 0x7f, 0x7f, 0x4e, 0x0, 0x0, 0x0, 0x0},    //4
    {0x0, 0x0, 0x0, 0x0, 0xfe, 0xfe, 0xfe, 0xce, 0xce, 0x8e, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x71, 0x71, 0x71, 0x71, 0x71, 0x7f, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0},  //5
    {0x0, 0x0, 0x0, 0x0, 0xfc, 0xfe, 0x86, 0x86, 0x86, 0x9e, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x7f, 0x73, 0x61, 0x73, 0x7f, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0}, //6
    {0x0, 0x0, 0x0, 0x0, 0xe, 0xe, 0xe, 0xe, 0x8e, 0xfe, 0x7e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78, 0x7e, 0xf, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},          //7
    {0x0, 0x0, 0x0, 0x0, 0x7c, 0xfe, 0xce, 0x86, 0xce, 0xfe, 0x7c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x7f, 0x73, 0x61, 0x73, 0x7f, 0x3e, 0x0, 0x0, 0x0, 0x0, 0x0}, //8
    {0x0, 0x0, 0x0, 0x0, 0x7c, 0xfe, 0xce, 0x86, 0xce, 0xfe, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x79, 0x61, 0x61, 0x61, 0x7f, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0}  //9 
};


/*Generated using mapGen utility*/
unsigned char symbolMap[NUM_SYMBOLS][32]={
    {0x0, 0x0, 0xc, 0x12, 0x12, 0xc, 0x0, 0xf8, 0xfc, 0xfe, 0xe, 0xe, 0x1e, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x3f, 0x7f, 0x70, 0x70, 0x78, 0x3c, 0x0, 0x0},     //Degree Celsius
    {0x0, 0x0, 0xc, 0x12, 0x12, 0xc, 0x0, 0xfe, 0xfe, 0xfe, 0xe, 0xe, 0x1e, 0x3e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x7f, 0x7f, 0x7f, 0x43, 0x3, 0x7, 0x0, 0x0, 0x0},       //Degree Fahrenheit
    {0x0, 0x0, 0x0, 0x0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0},           //Minus
    {0x0, 0x0, 0x0, 0xe, 0xd3, 0x69, 0xa6, 0x4c, 0x4c, 0xa6, 0x69, 0xd3, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0xf, 0x34, 0x23, 0x4c, 0xb3, 0xb3, 0x4c, 0x23, 0x34, 0xf, 0x6, 0x0, 0x0},   //Rpi Logo
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},                   //NULL Symbol
};

/*Generated using mapGen utility*/
unsigned char ipMap[NUM_IP][16]={
    {0xf8, 0xfc, 0xe, 0x6, 0x6, 0xfc, 0xf8, 0x0, 0x1f, 0x3f, 0x70, 0x60, 0x60, 0x3f, 0x1f, 0x0},
    {0x0, 0x10, 0x18, 0xfc, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x70, 0x70, 0x7f, 0x7f, 0x70, 0x70, 0x0},
    {0x1c, 0x1e, 0xe, 0xe, 0x8e, 0xfe, 0xfc, 0x0, 0x78, 0x7c, 0x7e, 0x77, 0x73, 0x71, 0x70, 0x0},
    {0x1c, 0x1e, 0xe, 0x8e, 0xce, 0xfe, 0x7c, 0x0, 0x38, 0x78, 0x70, 0x71, 0x73, 0x7f, 0x3e, 0x0},
    {0x80, 0xc0, 0xe0, 0x70, 0x38, 0xfc, 0xfe, 0x0, 0xf, 0xf, 0xe, 0xe, 0xe, 0x7f, 0x7f, 0x0},
    {0xfe, 0xfe, 0xfe, 0xce, 0xce, 0x8e, 0xe, 0x0, 0x71, 0x71, 0x71, 0x71, 0x71, 0x7f, 0x3f, 0x0},
    {0xfc, 0xfe, 0x86, 0x86, 0x86, 0x9e, 0x1c, 0x0, 0x3f, 0x7f, 0x73, 0x61, 0x73, 0x7f, 0x3f, 0x0},
    {0xe, 0xe, 0xe, 0xe, 0x8e, 0xfe, 0x7e, 0x0, 0x0, 0x0, 0x78, 0x7e, 0xf, 0x3, 0x0, 0x0},
    {0x7c, 0xfe, 0xce, 0x86, 0xce, 0xfe, 0x7c, 0x0, 0x3e, 0x7f, 0x73, 0x61, 0x73, 0x7f, 0x3e, 0x0},
    {0x7c, 0xfe, 0xce, 0x86, 0xce, 0xfe, 0xfc, 0x0, 0x38, 0x79, 0x61, 0x61, 0x61, 0x7f, 0x3f, 0x0},
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x78, 0x78, 0x30, 0x0, 0x0}
};

/*Render a single digit on display at specified co-ordinates*/
void renderDigit(int digit,const int x,const int y){
    sendCommand(SSD1306_SET_COLUMN);
    sendCommand(y);                     //Column Start
    sendCommand(y+FONT_WIDTH);          //Column End
    sendCommand(SSD1306_SET_PAGE); 
    sendCommand(x);                     //Page Start
    sendCommand(x+FONT_HEIGHT);         //Page End

    sendDataBlock(digitMap[digit],32);
}
/*Render a single symbol on display at specified co-ordinates*/
void renderSymbol(symbol sym,const int x,const int y){
    sendCommand(SSD1306_SET_COLUMN);
    sendCommand(y);                     //Column Start
    sendCommand(y+FONT_WIDTH);          //Column End
    sendCommand(SSD1306_SET_PAGE); 
    sendCommand(x);                     //Page Start
    sendCommand(x+FONT_HEIGHT);         //Page End
    
    sendDataBlock(symbolMap[sym],32);
}

/*Convert character to corresponding index in ipMap*/
int charToIPValue(char a){
    if (a-'0' >=0 && a-'0' <=9){
        return a-'0';
    }
    else if (a=='.'){
        return 11;
    } else{
        return 10;
    }
}

/*Render a single symbol on display at specified co-ordinates*/
void renderIPSymbol(char sym,const int x,const int y){
    sendCommand(SSD1306_SET_COLUMN);
    sendCommand(y);                     //Column Start
    sendCommand(y+8);          //Column End
    sendCommand(SSD1306_SET_PAGE); 
    sendCommand(x);                     //Page Start
    sendCommand(x+FONT_HEIGHT);         //Page End
    
    sendDataBlock(ipMap[charToIPValue(sym)],16);
}


void renderIPString(const char* str){
    int len=0;
    while(str[len]!='\0'){
        len++;
    }
    for(int i=0;i<len;i++){
        renderIPSymbol(str[i],4,i*8);
    }
}


/*Display digits and symbols to test*/
void renderTest(void){
    renderDigit(0,0,8);
    renderDigit(1,0,40);
    renderDigit(2,0,72);
    renderDigit(3,0,104);
    renderDigit(4,2,8);
    renderDigit(5,2,40);
    renderDigit(6,2,72);
    renderDigit(7,2,104);
    renderDigit(8,4,8);
    renderDigit(9,4,40);
    renderSymbol(DEGREE_CELSIUS,4,72);
    renderSymbol(DEGREE_FAHRENHEIT,4,104);
}

/*Initializing sequence for SSD1306 display. More details about initialization sequence can be found in the SSD1306 Documentation.*/
void initDisplay(void){
    sendCommand(SSD1306_DISPLAY_OFF); 
    sendCommand(SSD1306_SET_CLK_DR_OSC_FRQ);
    sendCommand(CLK_DR_OSC_FRQ); 
    sendCommand(SSD1306_SET_MUX_RATIO); 
    sendCommand(MUX64); 
    sendCommand(SSD1306_SET_DISPLAY_OFFSET); 
    sendCommand(OFFSET_VALUE); 
    sendCommand(SSD1306_SET_DISPLAY_START_FIRST);
    sendCommand(SSD1306_SET_CHARGE_PUMP); 
    sendCommand(ENABLE_PUMP);
    sendCommand(SSD1306_SET_MEM_ADDR_MODE);
    sendCommand(ADDR_MODE_HZ); 
    sendCommand(SSD1306_SET_SEGMENT_REMAP127); 
    sendCommand(SSD1306_SET_COM_OUT_DESCENDING); 
    sendCommand(SSD1306_SET_COM_CONFIG); 
    sendCommand(COM_CONFIG); 
    sendCommand(SSD1306_SET_CONTRAST); 
    sendCommand(CONTRAST); 
    sendCommand(SSD1306_SET_PRE_CHARGE_PERIOD); 
    sendCommand(PERIOD); 
    sendCommand(SSD1306_SET_VCOMH_DESELECT_LEVEL); 
    sendCommand(VCOMH_DESELECT_LEVEL); 
    sendCommand(SSD1306_SET_DISPLAY_ON_RAM); 
    sendCommand(SSD1306_SET_DISPLAY_NORMAL); 
    sendCommand(SSD1306_SET_SCROLL_OFF); 
    sendCommand(SSD1306_DISPLAY_ON);

    printf("SSD1306 display ready!");

    /*for fast clear sendDataBlock can be used. Try it!*/
    for(int i=0;i<128*8;i++){ //Clear any garbage pixels
        sendDataByte(NULL_BYTE);
    }
}

/*Clear the display contents*/
void clearDisplay(void){
    sendCommand(SSD1306_SET_COLUMN); 
    sendCommand(DISPLAY_BEGIN_COL);     //First Column
    sendCommand(DISPLAY_END_COL);       //Last Column
    sendCommand(SSD1306_SET_PAGE); 
    sendCommand(DISPLAY_BEGIN_PAGE);    //Set Page start and end addresses
    sendCommand(DISPLAY_END_PAGE);      //Set Page start and end addresses

    /*for fast clear sendDataBlock can be used. Try it!*/
    for(int i=0;i<128*8;i++){
        sendDataByte(NULL_BYTE);
    }
}

void initOLED(short SDA, short SCL)
{
    short GPIO_FUNC_I2C = 3; // dÃ©finie quelque part, c'est sa bonne valeur
    i2c_init(i2c_default, 400 * 1000); // Initialize I2C with clock fequency 400kHz
    gpio_set_function(SDA, GPIO_FUNC_I2C);
    gpio_set_function(SCL, GPIO_FUNC_I2C);
    gpio_pull_up(SDA);
    gpio_pull_up(SCL);
    sleep_ms(200);
    initDisplay();
}